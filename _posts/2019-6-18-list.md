>defautlt

**这个关键字通常在接口里面使用，使用了这个关键字，那么方法可以由自己的实现内容，在实现接口的时候可以选择不实现这个方法，但是如果实现了多个接口的情况下如果有不同接口里面都申明了相同的方法，那么实现类里面必须要实现一个默认的default方法，否则报错（TODO）**

>list

list是一个有序集合，他不支持空值。支持重复的值。

```java

public interface List<E> extends Collection<E> {
    // Query Operations

    /**
     * 返回list的大小
     */
    int size();

    /**
     * list是否为空。
     */
    boolean isEmpty();

    /**
     * 是否包含一个元素，如果类型不对抛出类型转换异常   当这个list不允许null值的时候 这个元素又是null值 会抛出nullException
     * Rellection.html#optional-restrictions">optional</a>)
     */
    boolean contains(Object o);

    /**
     * 返回一个迭代器。
     */
    Iterator<E> iterator();

    /**
     * 返回一个顺序相同的包含所有元素的数组，即便是用数组实现的list也需要clone一份新的，这个新的数组在外面是可以随意修改的。
     */
    Object[] toArray();

    /**
     * 返回一个特定对象的数组，如果给的数组a的size大于要返回的数组，那么 * 剩余的部分会被置为空。
     * String[] a = list.toArray(new String[0])
     */
    <T> T[] toArray(T[] a);


    // Modification Operations

    /**
     *  朝着队列尾部天添加一个元素
     *
     * @param e element to be appended to this list
     * @return <tt>true</tt> (as specified by {@link Collection#add})
     * @throws UnsupportedOperationException if the <tt>add</tt> operation
     *         is not supported by this list
     * @throws ClassCastException if the class of the specified element
     *         prevents it from being added to this list
     * @throws NullPointerException if the specified element is null and this
     *         list does not permit null elements
     * @throws IllegalArgumentException if some property of this element
     *         prevents it from being added to this list
     */
    boolean add(E e);

    /**
     * 删除列表里面第一个出现的元素。如果列表包括这个元素就返回true
     *
     * @param o element to be removed from this list, if present
     * @return <tt>true</tt> if this list contained the specified element
     * @throws ClassCastException if the type of the specified element
     *         is incompatible with this list
     * (<a href="Collection.html#optional-restrictions">optional</a>)
     * @throws NullPointerException if the specified element is null and this
     *         list does not permit null elements
     * (<a href="Collection.html#optional-restrictions">optional</a>)
     * @throws UnsupportedOperationException if the <tt>remove</tt> operation
     *         is not supported by this list
     */
    boolean remove(Object o);


    // 批量修改操作

    /**
     * 如果这个列表里面包含集合c里面所有的元素，返回true。
     *
     * @param  c collection to be checked for containment in this list
     * @return <tt>true</tt> if this list contains all of the elements of the
     *         specified collection
     * @throws ClassCastException if the types of one or more elements
     *         in the specified collection are incompatible with this
     *         list
     * (<a href="Collection.html#optional-restrictions">optional</a>)
     * @throws NullPointerException if the specified collection contains one
     *         or more null elements and this list does not permit null
     *         elements
     *         (<a href="Collection.html#optional-restrictions">optional</a>),
     *         or if the specified collection is null
     * @see #contains(Object)
     */
    boolean containsAll(Collection<?> c);

    /**
     * 向队列尾部添加一系列的元素，这个一系列的元素的顺序取决于这个集合的迭代器，如果这个集合是this，那会出现
     * UnsupportedOperationException 
     *
     * @param c collection containing elements to be added to this list
     * @return <tt>true</tt> if this list changed as a result of the call
     * @throws UnsupportedOperationException if the <tt>addAll</tt> operation
     *         is not supported by this list
     * @throws ClassCastException if the class of an element of the specified
     *         collection prevents it from being added to this list
     * @throws NullPointerException if the specified collection contains one
     *         or more null elements and this list does not permit null
     *         elements, or if the specified collection is null
     * @throws IllegalArgumentException if some property of an element of the
     *         specified collection prevents it from being added to this list
     * @see #add(Object)
     */
    boolean addAll(Collection<? extends E> c);

    /**
     * 向定位为index地方加入一个集合的所有元素，顺序由迭代器决定，不能addAll（this)
     * 
     *
     * @param index index at which to insert the first element from the
     *              specified collection
     * @param c collection containing elements to be added to this list
     * @return <tt>true</tt> if this list changed as a result of the call
     * @throws UnsupportedOperationException if the <tt>addAll</tt> operation
     *         is not supported by this list
     * @throws ClassCastException if the class of an element of the specified
     *         collection prevents it from being added to this list
     * @throws NullPointerException if the specified collection contains one
     *         or more null elements and this list does not permit null
     *         elements, or if the specified collection is null
     * @throws IllegalArgumentException if some property of an element of the
     *         specified collection prevents it from being added to this list
     * @throws IndexOutOfBoundsException if the index is out of range
     *         (<tt>index &lt; 0 || index &gt; size()</tt>)
     */
    boolean addAll(int index, Collection<? extends E> c);

    /**
     * 删除在list出现的在集合里面有的元素。如果队列只要删除了一个元素就会返回true
     * specified collection (optional operation).
     *
     * @param c collection containing elements to be removed from this list
     * @return <tt>true</tt> if this list changed as a result of the call
     * @throws UnsupportedOperationException if the <tt>removeAll</tt> operation
     *         is not supported by this list
     * @throws ClassCastException if the class of an element of this list
     *         is incompatible with the specified collection
     * (<a href="Collection.html#optional-restrictions">optional</a>)
     * @throws NullPointerException if this list contains a null element and the
     *         specified collection does not permit null elements
     *         (<a href="Collection.html#optional-restrictions">optional</a>),
     *         or if the specified collection is null
     * @see #remove(Object)
     * @see #contains(Object)
     */
    boolean removeAll(Collection<?> c);

    /**
     * 仅仅保留在list中存在在集合中也存在的元素。
     * 
     * 
     * 
     *
     * @param c collection containing elements to be retained in this list
     * @return <tt>true</tt> if this list changed as a result of the call
     * @throws UnsupportedOperationException if the <tt>retainAll</tt> operation
     *         is not supported by this list
     * @throws ClassCastException if the class of an element of this list
     *         is incompatible with the specified collection
     * (<a href="Collection.html#optional-restrictions">optional</a>)
     * @throws NullPointerException if this list contains a null element and the
     *         specified collection does not permit null elements
     *         (<a href="Collection.html#optional-restrictions">optional</a>),
     *         or if the specified collection is null
     * @see #remove(Object)
     * @see #contains(Object)
     */
    boolean retainAll(Collection<?> c);

    /**
     * 用operator计算的结果替换原来的元素。类似Ts map方法
     *
     * @implSpec
     * The default implementation is equivalent to, for this {@code list}:
     * <pre>{@code
     *     final ListIterator<E> li = list.listIterator();
     *     while (li.hasNext()) {
     *         li.set(operator.apply(li.next()));
     *     }
     * }</pre>
     *
     * If the list's list-iterator does not support the {@code set} operation
     * then an {@code UnsupportedOperationException} will be thrown when
     * replacing the first element.
     *
     * @param operator the operator to apply to each element
     * @throws UnsupportedOperationException if this list is unmodifiable.
     *         Implementations may throw this exception if an element
     *         cannot be replaced or if, in general, modification is not
     *         supported
     * @throws NullPointerException if the specified operator is null or
     *         if the operator result is a null value and this list does
     *         not permit null elements
     *         (<a href="Collection.html#optional-restrictions">optional</a>)
     * @since 1.8
     */
    default void replaceAll(UnaryOperator<E> operator) {
        Objects.requireNonNull(operator);
        final ListIterator<E> li = this.listIterator();
        while (li.hasNext()) {
            li.set(operator.apply(li.next()));
        }
    }

    /**
     * 对列表里面的元素排序，根据传入的Comparator，如果传入是是null那么需要列表里面的元素都是实现了comparable接口
     * 如果要使用default的方法实现，那么需要支持toArray 方法，这个实现是一个稳定的自适应的归并排序。
     * @param c the {@code Comparator} used to compare list elements.
     *          A {@code null} value indicates that。 the elements'
     *          {@linkplain Comparable natural ordering} should be used
     * @throws ClassCastException if the list contains elements that are not
     *         <i>mutually comparable</i> using the specified comparator
     * @throws UnsupportedOperationException if the list's list-iterator does
     *         not support the {@code set} operation
     * @throws IllegalArgumentException
     *         (<a href="Collection.html#optional-restrictions">optional</a>)
     *         if the comparator is found to violate the {@link Comparator}
     *         contract
     * @since 1.8
     */
    @SuppressWarnings({"unchecked", "rawtypes"})
    default void sort(Comparator<? super E> c) {
        Object[] a = this.toArray();
        Arrays.sort(a, (Comparator) c);
        ListIterator<E> i = this.listIterator();
        for (Object e : a) {
            i.next();
            i.set((E) e);
        }
    }

    /**
     * 删除所有元素。
     *
     * @throws UnsupportedOperationException if the <tt>clear</tt> operation
     *         is not supported by this list
     */
    void clear();


    // 比较和散列

    /**
     * 和一个元素对比，当这个元素也是列表，里面元素个数相同的时候，然后元素的值都是相同的时候返回true、
     * @param o the object to be compared for equality with this list
     * @return <tt>true</tt> if the specified object is equal to this list
     */
    boolean equals(Object o);

    /**
     *     int hashCode = 1;
     *     for (E e : list)
     *         hashCode = 31*hashCode + (e==null ? 0 : e.hashCode());
     * 返回一个hash值，这个hash值由上面的计算方式计算，如果一个list和另一个listequals 一致，那么他们hashcode也应该是一样的
     * @return the hash code value for this list
     * @see Object#equals(Object)
     * @see #equals(Object)
     */
    int hashCode();


    // 位置访问操作

    /**
     * 返回第index位的操作。
     *
     * @param index index of the element to return
     * @return the element at the specified position in this list
     * @throws IndexOutOfBoundsException if the index is out of range
     *         (<tt>index &lt; 0 || index &gt;= size()</tt>)
     */
    E get(int index);

    /**
     * 替换第index为的元素
     *
     * @param index index of the element to replace
     * @param element element to be stored at the specified position
     * @return the element previously at the specified position
     * @throws UnsupportedOperationException if the <tt>set</tt> operation
     *         is not supported by this list
     * @throws ClassCastException if the class of the specified element
     *         prevents it from being added to this list
     * @throws NullPointerException if the specified element is null and
     *         this list does not permit null elements
     * @throws IllegalArgumentException if some property of the specified
     *         element prevents it from being added to this list
     * @throws IndexOutOfBoundsException if the index is out of range
     *         (<tt>index &lt; 0 || index &gt;= size()</tt>)
     */
    E set(int index, E element);

    /**
     * 在第index位插入一个元素
     *
     * @param index index at which the specified element is to be inserted
     * @param element element to be inserted
     * @throws UnsupportedOperationException if the <tt>add</tt> operation
     *         is not supported by this list
     * @throws ClassCastException if the class of the specified element
     *         prevents it from being added to this list
     * @throws NullPointerException if the specified element is null and
     *         this list does not permit null elements
     * @throws IllegalArgumentException if some property of the specified
     *         element prevents it from being added to this list
     * @throws IndexOutOfBoundsException if the index is out of range
     *         (<tt>index &lt; 0 || index &gt; size()</tt>)
     */
    void add(int index, E element);

    /**
     * 删除第index位的元素
     *
     * @param index the index of the element to be removed
     * @return the element previously at the specified position
     * @throws UnsupportedOperationException if the <tt>remove</tt> operation
     *         is not supported by this list
     * @throws IndexOutOfBoundsException if the index is out of range
     *         (<tt>index &lt; 0 || index &gt;= size()</tt>)
     */
    E remove(int index);


    // 查找操作

    /**
     * 查找一个元素，返回他的坐标，如果有相同的那么返回坐标最低的那个，找不到就返回-1.
     *
     * @param o element to search for
     * @return the index of the first occurrence of the specified element in
     *         this list, or -1 if this list does not contain the element
     * @throws ClassCastException if the type of the specified element
     *         is incompatible with this list
     *         (<a href="Collection.html#optional-restrictions">optional</a>)
     * @throws NullPointerException if the specified element is null and this
     *         list does not permit null elements
     *         (<a href="Collection.html#optional-restrictions">optional</a>)
     */
    int indexOf(Object o);

    /**
     * 查找一个元素的下表，从最后面开始找，返回坐标最大的元素
     *
     * @param o element to search for
     * @return the index of the last occurrence of the specified element in
     *         this list, or -1 if this list does not contain the element
     * @throws ClassCastException if the type of the specified element
     *         is incompatible with this list
     *         (<a href="Collection.html#optional-restrictions">optional</a>)
     * @throws NullPointerException if the specified element is null and this
     *         list does not permit null elements
     *         (<a href="Collection.html#optional-restrictions">optional</a>)
     */
    int lastIndexOf(Object o);


    // 迭代器 

    /**
     * 返回一个list的迭代器
     * @return a list iterator over the elements in this list (in proper
     *         sequence)
     */
    ListIterator<E> listIterator();

    /**
     * 根据index返回一个迭代器，这个迭代器从第index个元素开始
     *
     * @param index index of the first element to be returned from the
     *        list iterator (by a call to {@link ListIterator#next next})
     * @return a list iterator over the elements in this list (in proper
     *         sequence), starting at the specified position in the list
     * @throws IndexOutOfBoundsException if the index is out of range
     *         ({@code index < 0 || index > size()})
     */
    ListIterator<E> listIterator(int index);

    // View

    /**
     * 返回一个字列表，如果调用此方法的时候还在修改this的值那么会发生意想不到的错误
     * @param fromIndex low endpoint (inclusive) of the subList
     * @param toIndex high endpoint (exclusive) of the subList
     * @return a view of the specified range within this list
     * @throws IndexOutOfBoundsException for an illegal endpoint index value
     *         (<tt>fromIndex &lt; 0 || toIndex &gt; size ||
     *         fromIndex &gt; toIndex</tt>)
     */
    List<E> subList(int fromIndex, int toIndex);

    /**
     * 并行的迭代器
     *
     * @return a {@code Spliterator} over the elements in this list
     * @since 1.8
     */
    @Override
    default Spliterator<E> spliterator() {
        return Spliterators.spliterator(this, Spliterator.ORDERED);
    }
}

```

>Spliterator

```java

/**
 * 用于遍历和拆分元素的对象. 这个资源的元素可以来自, 一个数组, 一个集合,  一个IO频道, 或者一个公共的方法.
 * 一个Spliterator可以使用tryAdvance来单独遍历纹身或者使用forEachRemaining 按顺序皮脸处理
 * 一个spliterator也可使用trySplit来将元素拆分成其他的spliterator，然后用来干其他平行的操作，
 * 在使用这个Spliterator的时候，对于那种不可分或者高度不平衡或者低效的情况下是不可能受益。 
 * 拆分干净元素的Spliterator只是对自己部分的元素生效
 * 一个Spliterator也能同过 characteristics 方法返回一个集合，结构，资源，或者元素的特点。
 * 一个分割器通过charactoristics()返回一个特征值，详情看下面的特征值.  这个特征值一般会被用来简化
 * 一个特征值就是通过位图来标记的。
 * 一些特征值还限制了方法的行为，ex 如果特征值是ordered，那么遍历的顺序应该符合这个排序的顺序
 * 未来可能会定义新的特征值，所以在实现的时候不能将这个设置为没有列出来的值
 * 一个spliterator在下列情况下不会被定位 Iimmutable 或者是 concurrent 不可改变或者是线程安全的。
 * 当一个分割者绑定一个元素资源的时候，或者这个元素检测到了自己被绑定时。当一个延时绑定的分割者，在第一次
 * 遍历，拆分，或者查询的他预计大小的时候时候的时候绑定元素资源，而不是当分割者被创建出来的时候。不是延时绑定的分割者
 * 是在构造方法或者是调用其他的方法的时候绑定。遍历的时候修改会影响之前的绑定。如果结构的接口里面检测ConcurrentModificationException
 * 那么你就得抛出,这个异常。执行这个操作的分割者被叫做 fail-fast,forEachRemaining()批量遍历的方法。
 * 在遍历的时候应该是遍历所有的元素来计算影响而不是每个都计算一遍。
 *
 * 分割者可以通过 estimateSize()来提供一个估计的大小，这个瘦到size特征值的影响，
 * 这个数值和你遍历过程中遇到的节点数完全一致，即便是不够了解这这个size，在处资源的时候估计值也
 * 是用用的,例如他可以帮你确定在未来是拆分还是遍历。
 *
 * 尽管在并行算法上这个是明显的适用性，但是分割器不一定是线程安全的，使用并行算法实现分割器的时候，
 * 应该确定的一件事情就是同一时间只有一个线程在运行分割器。这个通常会用串行序列来实现，这个也是常见的递归分解
 * 并行算法的常规操作。一个线程在使用 trysplit来拆分的时候婴孩交出（可能拆分或者是遍历）spliterator来个其他的线程。
 * 如果两个线程同时操作一个spliterator来进行拆分和遍历是没有定义的行为，如果源线程想把spliterator给其他的线程操作，
 * 最好的方式是在使用tryadvance之前使用，所以为了保证准确性这 estimateSize 只是在遍历开始之前有用。
 * 原始的类型提供了默认的分割器实现方法：ofInt 等。tryAdvance和forEachRemaing 包装了这些类型实现了
 * 对应的包装类，这些装箱可能会影响原来的性能，所以为了避免装箱，我们提供了这些基本类型方法使用
 * tryAdvance（intConsumer） forEachRemaining（intConsumer）优于原来的直接使用Consumer接口。
 * 使用consumer接口方法，原来的值builder改变顺序。
 *
 * @apiNote
 * spliterator 就像迭代器一样是为了遍历一个资源的元素的，spliterator的API被设计成支持高效并行的是为了完成顺序遍历的需求，
 * 为了支持分解和单个元素的迭代。除此之外，他还被设计要比迭代器访问每个元素的开销小。也比面了next和hashnext的实现
 *
 * 对于易变的资源来说，在使用spliterator的时候，可能在拆分的时候里面的资源就和开始的时候不一样了，比如在使用stream的时候
 * 可以通过以下方法来控制易变的结构  
 * 不能在结构上收到干扰，ex:CopyOnWriteArrayList 是不可变的资源，在一个分割器创建出来的时候他的特征值就是immutable
 * 资源控制并发的修改。
 * 一个concurrentHashMap里面的key set集合就是一个并发的资源，这个资源的分割器被创建出来的时候就是 concurrent特征值
 * 
 * 一个易变资源提供延时绑定和 fail-fast的结构。（就是我不能处理但是我抛出异常）
 * 比如说ArrayList的就是实现了这个异常。
 * 
 * 然后就是不实现后期绑定 但是是一个快速失败的结构，这个增加抛出并行修改异常的跑车概率  因为构造方法到使用之间可能被修改
 * 
 * 然后就是  实现后期绑定但是不实现快速失败，这个会导致风险没有办法检查
 * 
 * 都不提供，既增加了风险又不检测
 *
 * <p><b>Example.</b> Here is a class (not a very useful one, except
 * for illustration) that maintains an array in which the actual data
 * are held in even locations, and unrelated tag data are held in odd
 * locations. Its Spliterator ignores the tags.
 *
 * <pre> {@code
 * class TaggedArray<T> {
 *   private final Object[] elements; // immutable after construction
 *   TaggedArray(T[] data, Object[] tags) {
 *     int size = data.length;
 *     if (tags.length != size) throw new IllegalArgumentException();
 *     this.elements = new Object[2 * size];
 *     for (int i = 0, j = 0; i < size; ++i) {
 *       elements[j++] = data[i];
 *       elements[j++] = tags[i];
 *     }
 *   }
 *
 *   public Spliterator<T> spliterator() {
 *     return new TaggedArraySpliterator<>(elements, 0, elements.length);
 *   }
 *
 *   static class TaggedArraySpliterator<T> implements Spliterator<T> {
 *     private final Object[] array;
 *     private int origin; // current index, advanced on split or traversal
 *     private final int fence; // one past the greatest index
 *
 *     TaggedArraySpliterator(Object[] array, int origin, int fence) {
 *       this.array = array; this.origin = origin; this.fence = fence;
 *     }
 *
 *     public void forEachRemaining(Consumer<? super T> action) {
 *       for (; origin < fence; origin += 2)
 *         action.accept((T) array[origin]);
 *     }
 *
 *     public boolean tryAdvance(Consumer<? super T> action) {
 *       if (origin < fence) {
 *         action.accept((T) array[origin]);
 *         origin += 2;
 *         return true;
 *       }
 *       else // cannot advance
 *         return false;
 *     }
 *
 *     public Spliterator<T> trySplit() {
 *       int lo = origin; // divide range in half
 *       int mid = ((lo + fence) >>> 1) & ~1; // force midpoint to be even
 *       if (lo < mid) { // split out left half
 *         origin = mid; // reset this Spliterator's origin
 *         return new TaggedArraySpliterator<>(array, lo, mid);
 *       }
 *       else       // too small to split
 *         return null;
 *     }
 *
 *     public long estimateSize() {
 *       return (long)((fence - origin) / 2);
 *     }
 *
 *     public int characteristics() {
 *       return ORDERED | SIZED | IMMUTABLE | SUBSIZED;
 *     }
 *   }
 * }}</pre>
 * 并行计算的框架：就像stream包中的，使用spliterator来做一个并行计算，这里有个实现方案，
 * 可以实现并行计算。将原来的任务拆分成不能拆分的任务再来完成，如果子任务之间没有顺序要求那么可以更加自由的拆分
 * CountedCompleter 里面有相同的操作。
 *
 * <pre>{@code
 * static <T> void parEach(TaggedArray<T> a, Consumer<T> action) {
 *   Spliterator<T> s = a.spliterator();
 *   long targetBatchSize = s.estimateSize() / (ForkJoinPool.getCommonPoolParallelism() * 8);
 *   new ParEach(null, s, action, targetBatchSize).invoke(); // 将这个ConuntedComplete加入到ForkJoinTask里面
 * }
 *
 * static class ParEach<T> extends CountedCompleter<Void> {
 *   final Spliterator<T> spliterator;
 *   final Consumer<T> action;
 *   final long targetBatchSize;
 *
 *   ParEach(ParEach<T> parent, Spliterator<T> spliterator,
 *           Consumer<T> action, long targetBatchSize) {
 *     super(parent);
 *     this.spliterator = spliterator; this.action = action;
 *     this.targetBatchSize = targetBatchSize;
 *   }
 *
 *   public void compute() { //在invoke里面会判断
 *     Spliterator<T> sub;
 *     while (spliterator.estimateSize() > targetBatchSize &&
 *            (sub = spliterator.trySplit()) != null) {
 *       addToPendingCount(1);
 *       new ParEach<>(this, sub, action, targetBatchSize).fork(); 吧这个任务加到队列里面去 ForkJointask里面去 
 *     }
 *     spliterator.forEachRemaining(action);//在这里处理action
 *     propagateCompletion();更新状态 类似于出队列的方法
 *   }
 * }}</pre>
 *
 * @implNote
 * 如果布尔值系统属性设置为true则对原子类型操作的时候吐过如果
 * If the boolean system property {@code org.openjdk.java.util.stream.tripwire}
 * is set to {@code true} then diagnostic warnings are reported if boxing of
 * primitive values occur when operating on primitive subtype specializations.
 *
 * @param <T> the type of elements returned by this Spliterator
 *
 * @see Collection
 * @since 1.8
 */
public interface Spliterator<T> {
    /**
     * If a remaining element exists, performs the given action on it,
     * returning {@code true}; else returns {@code false}.  If this
     * Spliterator is {@link #ORDERED} the action is performed on the
     * next element in encounter order.  Exceptions thrown by the
     * action are relayed to the caller.
     * 如果有剩余的元素将action给这些元素执行，并且返回true否者返回false，如果这个分割器是有顺序的
     * 那么这个consumer的执行就按照这个顺序要，异常会被转发给调用者
     * @param action The action
     * @return {@code false} if no remaining elements existed
     * upon entry to this method, else {@code true}.
     * @throws NullPointerException if the specified action is null
     */
    boolean tryAdvance(Consumer<? super T> action);

    /**
     * Performs the given action for each remaining element, sequentially in
     * the current thread, until all elements have been processed or the action
     * throws an exception.  If this Spliterator is {@link #ORDERED}, actions
     * are performed in encounter order.  Exceptions thrown by the action
     * are relayed to the caller.
     * 每一个剩余的元素执行剩余consumer，在当前线程是有顺序的只有在所有节点都执行玩了，或者是发生了异常，如果
     * spliterator 是有序的那么执行的时候也是相应的顺序，默认的实现是调用tryadVance直到返回false。
     * @implSpec
     * The default implementation repeatedly invokes {@link #tryAdvance} until
     * it returns {@code false}.  It should be overridden whenever possible.
     *
     * @param action The action
     * @throws NullPointerException if the specified action is null
     */
    default void forEachRemaining(Consumer<? super T> action) {
        do { } while (tryAdvance(action));
    }

    /**
     * 拆分一个spliterator，如果一个soliterator是能够被拆分的，放回一个spliterator
     * 里面都是覆盖的元素，不会被这个spliterator返回。
     * If this spliterator can be partitioned, returns a Spliterator
     * covering elements, that will, upon return from this method, not
     * be covered by this Spliterator.
     *
     * <p>If this Spliterator is {@link #ORDERED}, the returned Spliterator
     * must cover a strict prefix of the elements.
     * 如果这元素是有序的，那么返回的分割器也是按照这个排序顺序来的
     * 除非这个spliterator 涵盖无数的元素，否则这个tryslit就有返回null的时候
     * <p>Unless this Spliterator covers an infinite number of elements,
     * repeated calls to {@code trySplit()} must eventually return {@code null}.
     * Upon non-null return:
     * 这里有几个原则：
     * 1 返回出来的分割器的通过 estimate返回出来的size应该比原来的大或者一样。
     * 2 如果spliterator是subsized 那么拆分之前的estimateSize返回的值应该
     * 拆分之后的所有spliterator返回的值求和一致。
     * <ul> 
     * <li>the value reported for {@code estimateSize()} before splitting,
     * must, after splitting, be greater than or equal to {@code estimateSize()}
     * for this and the returned Spliterator; and</li>
     * <li>if this Spliterator is {@code SUBSIZED}, then {@code estimateSize()}
     * for this spliterator before splitting must be equal to the sum of
     * {@code estimateSize()} for this and the returned Spliterator after
     * splitting.</li>
     * </ul>
     * 这个方法有一些情况会返回null，空值，遍历开始之后无法拆分，或者数据结构的原因，效率原因
     *
     * @apiNote
     * 如何使用这个方法高效的并行计算呢?如果是将元素平均拆分成两半，那么效率会很好。
     * 如果偏离了这个规则那么其实这个效率并不是很理想，ex：有人会用这个方法拆分一个树上面 
     * 的一个元素，没有能进一步拆分这些节点。一句话就是平衡偏差和过低的效率会导致并行效率的降低
     *
     * @return a {@code Spliterator} covering some portion of the
     * elements, or {@code null} if this spliterator cannot be split
     */
    Spliterator<T> trySplit();

    /**
     * 返回一个临时的元素个数，是你遍历遇到元素的个数综或者return max value，当个数没有办法计算的时候。
     * 如果一个spliterator是固定大小的，也没有进行拆分和遍历，或者一个spliterator的特征值包括subsized，也没有被拆分遍历过。
     * 那么这个临时大小返回的就是一次完整遍历的元素个数。这个估计值可能是不准确的，我们应按照trysplit的指定方式减少
     *
     * @apiNote
     * 哪怕是一个不精确的size，也是很有用的，ex：一个子spliterator是一个不太准确的平衡二叉树，
     * 那么这个方法会返回一个是他parent节点的值的1/2，那如果根节点没有维护这个size 那么就是深度的2次幂
     *
     * @return the estimated size, or {@code Long.MAX_VALUE} if infinite,
     *         unknown, or too expensive to compute.
     */
    long estimateSize();

    /**
     * 返回一个确切的长度，如果分割器是sized，不然就返回-1.
     * @implSpec
     * @return the exact size, if known, else {@code -1}.
     */
    default long getExactSizeIfKnown() {
        return (characteristics() & SIZED) == 0 ? -1L : estimateSize();
    }

    /**
     * 返回一个特征值。
     *
     * 如果特征值都不能保持一致的话，那么后边计算的也无法保证
     *
     * 在拆分之前和拆分之后的特征值是有可能不一样的
     * @return a representation of characteristics
     */
    int characteristics();

    /**
     * 如果有这个特征值就返回ture，如果没有这个特征值就返回false。
     *
     * @param characteristics the characteristics to check for
     * @return {@code true} if all the specified characteristics are present,
     * else {@code false}
     */
    default boolean hasCharacteristics(int characteristics) {
        return (characteristics() & characteristics) == characteristics;
    }

    /**
     * 如果spliterator是通过comparator来排序的，那么就返回这个 comparator，如果是通过 comparable
     * 或者是自然排序。如果这个spliterator不是sorted直接抛异常。
     *
     * @return a Comparator, or {@code null} if the elements are sorted in the
     * natural order.
     * @throws IllegalStateException if the spliterator does not report
     *         a characteristic of {@code SORTED}.
     */
    default Comparator<? super T> getComparator() {
        throw new IllegalStateException();
    }

    /**
     * 是不是有序的spliterator。
     *
     * 如果一个list是有序的那么他的迭代器也是有序的，这个和列表的实现有关。例如一般的list都是按照索引升序的，
     * 但是基于散列实现的hashset就没有保证顺序，但是在非交换并行计算里面都是期望有序的。
     */
    public static final int ORDERED    = 0x00000010;

    /**
     * 值是唯一的，判断依据是equals方法。
     */
    public static final int DISTINCT   = 0x00000001;

    /**
     * 这个值代表是遇到按照排序序列来的. 如果是这样的话可以使用getComparator来获取
     * 排序器，如果这个方法返回空就说明是自然字段。
     * 这个分割者应该也是ORDERED的
     *
     * @apiNote The spliterators for {@code Collection} classes in the JDK that
     * implement {@link NavigableSet} or {@link SortedSet} report {@code SORTED}.
     */100
    public static final int SORTED     = 0x00000004;

    /**
     * 在没有元素修改的情况下表示遍历所有元素的精确计数，表示了遍历或者是拆分之前的特征值表示是有限大小的
     *
     * @apiNote Most Spliterators for Collections, that cover all elements of a
     * {@code Collection} report this characteristic. Sub-spliterators, such as
     * those for {@link HashSet}, that cover a sub-set of elements and
     * approximate their reported size do not.
     */101000
    public static final int SIZED      = 0x00000040;

    /**
     * 表示遇到的元素都不为空
     */1100100
    public static final int NONNULL    = 0x00000100;

    /**
     * 这个特征值表示一个结构体没有办法被修改。例如增加替换等等，在遍历的过程中只能是遍历。
     * 一般用于遍历过程中的一些检测
     */110010000
    public static final int IMMUTABLE  = 0x00000400;

    /**
     * 这个特征值代表了元素资源是线程安全的，即便是在多线程操作中没有加上同步锁，
     * 如果是这样，那么这个分割器应该在遍历的使用后记录修改的影响
     * 有一些规则：在上层的分割器不应该同时具有 CONCURRENt和SIZED两种属性，如果是有限大小的，在
     * 修改资源的时候会修改影响，这个和SIZED关键字是相悖的。但是在子分割器中，是可以被标记成
     * SIZED的，因为在子分割器里面不涉及遍历的时候对资源文件修改。
     *
     * @apiNote 217/5000
     * 大多数并发收集保持一致性策略，保证Spliterator构造点上存在的元素的准确性，但可能不反映后续的添加或删除。
     */1111101000
    public static final int CONCURRENT = 0x00001000;

    /**
     * 所有通过trySplit出来的spliterator都是都是SIZED和SUNSIZED的，这意味着所有的子spliterator
     * 都是SIZED
     * 
     * @apiNote 例如顶级的分割器就像一个平衡二叉树一样只知道自己的size不知道自己子树的size
     */111110100000
    public static final int SUBSIZED = 0x00004000;

    /**
     * A Spliterator specialized for primitive values.
     * 处理基础类型的分割器
     *
     * @param <T> 返回元素的类型，是一个包装类。
     * @param <T_CONS> 基础类型的consumer，是一个专门用来实现基础类型的操作的。
     * @param <T_SPLITR> 基础类型的分割器，
     *
     * @see Spliterator.OfInt
     * @see Spliterator.OfLong
     * @see Spliterator.OfDouble
     * @since 1.8
     */
    public interface OfPrimitive<T, T_CONS, T_SPLITR extends Spliterator.OfPrimitive<T, T_CONS, T_SPLITR>>
            extends Spliterator<T> {
        @Override
        T_SPLITR trySplit();

        /**
         *
         * @param action The action
         * @return {@code false} if no remaining elements existed
         * upon entry to this method, else {@code true}.
         * @throws NullPointerException if the specified action is null
         */
        @SuppressWarnings("overloads")
        boolean tryAdvance(T_CONS action);

        /**
         *
         *
         * @param action The action
         * @throws NullPointerException if the specified action is null
         */
        @SuppressWarnings("overloads")
        default void forEachRemaining(T_CONS action) {
            do { } while (tryAdvance(action));
        }
    }

    /**
     * A Spliterator specialized for {@code int} values.
     * @since 1.8
     */
    public interface OfInt extends OfPrimitive<Integer, IntConsumer, OfInt> {

        @Override
        OfInt trySplit();

        @Override
        boolean tryAdvance(IntConsumer action);

        @Override
        default void forEachRemaining(IntConsumer action) {
            do { } while (tryAdvance(action));
        }

        /**
         * {@inheritDoc}
         * @implSpec
         * If the action is an instance of {@code IntConsumer} then it is cast
         * to {@code IntConsumer} and passed to
         * {@link #tryAdvance(java.util.function.IntConsumer)}; otherwise
         * the action is adapted to an instance of {@code IntConsumer}, by
         * boxing the argument of {@code IntConsumer}, and then passed to
         * {@link #tryAdvance(java.util.function.IntConsumer)}.
         */
        @Override
        default boolean tryAdvance(Consumer<? super Integer> action) {
            if (action instanceof IntConsumer) {
                return tryAdvance((IntConsumer) action);
            }
            else {
                if (Tripwire.ENABLED)
                    Tripwire.trip(getClass(),
                                  "{0} calling Spliterator.OfInt.tryAdvance((IntConsumer) action::accept)");
                return tryAdvance((IntConsumer) action::accept); //强转
            }
        }

        /**
         * {@inheritDoc}
         * @implSpec
         * If the action is an instance of {@code IntConsumer} then it is cast
         * to {@code IntConsumer} and passed to
         * {@link #forEachRemaining(java.util.function.IntConsumer)}; otherwise
         * the action is adapted to an instance of {@code IntConsumer}, by
         * boxing the argument of {@code IntConsumer}, and then passed to
         * {@link #forEachRemaining(java.util.function.IntConsumer)}.
         */
        @Override
        default void forEachRemaining(Consumer<? super Integer> action) {
            if (action instanceof IntConsumer) {
                forEachRemaining((IntConsumer) action);
            }
            else {
                if (Tripwire.ENABLED)
                    Tripwire.trip(getClass(),
                                  "{0} calling Spliterator.OfInt.forEachRemaining((IntConsumer) action::accept)");
                forEachRemaining((IntConsumer) action::accept); //强转
            }
        }
    }

    /**
     * A Spliterator specialized for {@code long} values.
     * @since 1.8
     */
    public interface OfLong extends OfPrimitive<Long, LongConsumer, OfLong> {

        @Override
        OfLong trySplit();

        @Override
        boolean tryAdvance(LongConsumer action);

        @Override
        default void forEachRemaining(LongConsumer action) {
            do { } while (tryAdvance(action));
        }

        /**
         * {@inheritDoc}
         * @implSpec
         * If the action is an instance of {@code LongConsumer} then it is cast
         * to {@code LongConsumer} and passed to
         * {@link #tryAdvance(java.util.function.LongConsumer)}; otherwise
         * the action is adapted to an instance of {@code LongConsumer}, by
         * boxing the argument of {@code LongConsumer}, and then passed to
         * {@link #tryAdvance(java.util.function.LongConsumer)}.
         */
        @Override
        default boolean tryAdvance(Consumer<? super Long> action) {
            if (action instanceof LongConsumer) {
                return tryAdvance((LongConsumer) action);
            }
            else {
                if (Tripwire.ENABLED)
                    Tripwire.trip(getClass(),
                                  "{0} calling Spliterator.OfLong.tryAdvance((LongConsumer) action::accept)");
                return tryAdvance((LongConsumer) action::accept);
            }
        }

        /**
         * {@inheritDoc}
         * @implSpec
         * If the action is an instance of {@code LongConsumer} then it is cast
         * to {@code LongConsumer} and passed to
         * {@link #forEachRemaining(java.util.function.LongConsumer)}; otherwise
         * the action is adapted to an instance of {@code LongConsumer}, by
         * boxing the argument of {@code LongConsumer}, and then passed to
         * {@link #forEachRemaining(java.util.function.LongConsumer)}.
         */
        @Override
        default void forEachRemaining(Consumer<? super Long> action) {
            if (action instanceof LongConsumer) {
                forEachRemaining((LongConsumer) action);
            }
            else {
                if (Tripwire.ENABLED)
                    Tripwire.trip(getClass(),
                                  "{0} calling Spliterator.OfLong.forEachRemaining((LongConsumer) action::accept)");
                forEachRemaining((LongConsumer) action::accept);
            }
        }
    }

    /**
     * A Spliterator specialized for {@code double} values.
     * @since 1.8
     */
    public interface OfDouble extends OfPrimitive<Double, DoubleConsumer, OfDouble> {

        @Override
        OfDouble trySplit();

        @Override
        boolean tryAdvance(DoubleConsumer action);

        @Override
        default void forEachRemaining(DoubleConsumer action) {
            do { } while (tryAdvance(action));
        }

        /**
         * {@inheritDoc}
         * @implSpec
         * If the action is an instance of {@code DoubleConsumer} then it is
         * cast to {@code DoubleConsumer} and passed to
         * {@link #tryAdvance(java.util.function.DoubleConsumer)}; otherwise
         * the action is adapted to an instance of {@code DoubleConsumer}, by
         * boxing the argument of {@code DoubleConsumer}, and then passed to
         * {@link #tryAdvance(java.util.function.DoubleConsumer)}.
         */
        @Override
        default boolean tryAdvance(Consumer<? super Double> action) {
            if (action instanceof DoubleConsumer) {
                return tryAdvance((DoubleConsumer) action);
            }
            else {
                if (Tripwire.ENABLED)
                    Tripwire.trip(getClass(),
                                  "{0} calling Spliterator.OfDouble.tryAdvance((DoubleConsumer) action::accept)");
                return tryAdvance((DoubleConsumer) action::accept);
            }
        }

        /**
         * {@inheritDoc}
         * @implSpec
         * If the action is an instance of {@code DoubleConsumer} then it is
         * cast to {@code DoubleConsumer} and passed to
         * {@link #forEachRemaining(java.util.function.DoubleConsumer)};
         * otherwise the action is adapted to an instance of
         * {@code DoubleConsumer}, by boxing the argument of
         * {@code DoubleConsumer}, and then passed to
         * {@link #forEachRemaining(java.util.function.DoubleConsumer)}.
         */
        @Override
        default void forEachRemaining(Consumer<? super Double> action) {
            if (action instanceof DoubleConsumer) {
                forEachRemaining((DoubleConsumer) action);
            }
            else {
                if (Tripwire.ENABLED)
                    Tripwire.trip(getClass(),
                                  "{0} calling Spliterator.OfDouble.forEachRemaining((DoubleConsumer) action::accept)");
                forEachRemaining((DoubleConsumer) action::accept);
            }
        }
    }
}

```

>迭代器

```java
/**
 * 一个list 的迭代器可以，用于遍历修改,获取元素的位置，一个迭代器没有当前元素，他总是通过previous和next
 * 来访问元素。一个迭代器的光标定位 如果说这个list长度为n那么他的位置就是所有list的间隙n+1
 * 在调用修改方法的时候需要注意的是修改的是通过previous或者是next返回的最后一个元素。
 
 * <PRE>
 *                      Element(0)   Element(1)   Element(2)   ... Element(n-1)
 * cursor positions:  ^            ^            ^            ^                  ^
 * </PRE>
 *
 * <p>This interface is a member of the
 * <a href="{@docRoot}/../technotes/guides/collections/index.html">
 * Java Collections Framework</a>.
 *
 * @author  Josh Bloch
 * @see Collection
 * @see List
 * @see Iterator
 * @see Enumeration
 * @see List#listIterator()
 * @since   1.2
 */
public interface ListIterator<E> extends Iterator<E> {
    // 查询炒作

    /**
     * 如果在迭代器遍历的方向上有下一个节点就返回true，
     *
     * @return {@code true} if the list iterator has more elements when
     *         traversing the list in the forward direction
     */
    boolean hasNext();

    /**
     * 返回下一个元素，如果没有就抛出异常。
     *
     * @return the next element in the list
     * @throws NoSuchElementException if the iteration has no next element
     */
    E next();

    /**
     * 如果在遍历的反方向上面有节点的话 返回true。
     *
     * @return {@code true} if the list iterator has more elements when
     *         traversing the list in the reverse direction
     */
    boolean hasPrevious();

    /**
     * 返回光标之前的节点，没有节点就抛异常。
     *
     * @return the previous element in the list
     * @throws NoSuchElementException if the iteration has no previous
     *         element
     */
    E previous();

    /**
     * 返回将要被next方法返回节点的index。
     *
     * @return the index of the element that would be returned by a
     *         subsequent call to {@code next}, or list size if the list
     *         iterator is at the end of the list
     */
    int nextIndex();

    /**
     * 返回将要被previous方法返回节点的index
     *
     * @return the index of the element that would be returned by a
     *         subsequent call to {@code previous}, or -1 if the list
     *         iterator is at the beginning of the list
     */
    int previousIndex();


    // 修改操作

    /**
     * 删除节点，这个节点是previous或者是next返回的最后一个节点，如果这个列表不支持修改，抛出不支持操作异常，
     * 要注意的是 在next 和 previous后面只能调用一次类似的方法  
     * @throws UnsupportedOperationException if the {@code remove}
     *         operation is not supported by this list iterator
     * @throws IllegalStateException if neither {@code next} nor
     *         {@code previous} have been called, or {@code remove} or
     *         {@code add} have been called after the last call to
     *         {@code next} or {@code previous}
     */
    void remove();

    /**
     * 替换一个节点 调用情况和上面的remove类似。
     *
     * @param e the element with which to replace the last element returned by
     *          {@code next} or {@code previous}
     * @throws UnsupportedOperationException if the {@code set} operation
     *         is not supported by this list iterator
     * @throws ClassCastException if the class of the specified element
     *         prevents it from being added to this list
     * @throws IllegalArgumentException if some aspect of the specified
     *         element prevents it from being added to this list
     * @throws IllegalStateException if neither {@code next} nor
     *         {@code previous} have been called, or {@code remove} or
     *         {@code add} have been called after the last call to
     *         {@code next} or {@code previous}
     */
    void set(E e);

    /**
     * 插入元素，如果next 或者是previous返回的有值，那么就加在这个节点的后面。如果没有节点，就加入一节点。 
     *
     * @param e the element to insert
     * @throws UnsupportedOperationException if the {@code add} method is
     *         not supported by this list iterator
     * @throws ClassCastException if the class of the specified element
     *         prevents it from being added to this list
     * @throws IllegalArgumentException if some aspect of this element
     *         prevents it from being added to this list
     */
    void add(E e);
}

```